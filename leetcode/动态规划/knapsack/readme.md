# 01背包问题

背包 bagweight 上限 4kg
最大价值 dp
物品数组 value[15,20,30] weight[1,3,4]

- 01背包
    - 1 拿
        重量增大，价值增大
    - 0 不拿
        前面的最优解
        每件物品只有一件

    完全背包 物品的数量 多
    多重背包 每个物品的数量都一样


- 暴力破解法 时间复杂度 O(2^n) 不合适

- 动态规划解决
    - 定义dp数组  dp[i][j] 二维？留印象
    最优子结构 dp[i][j] 最后一个是最值 dp[value.length-1][j]
    清楚 ij 的含义是什么? i 表示第i个物品 j 表示背包的重量
    物品 i 放进容量为j的背包中得到的最大价值

    矩阵 

    - 状态转移方程

    dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]]+value[i])

    - 初始化 重要工作
        子结构的分析 状态的方向 
    - 迭代
    - 返回结果

# 滚动数组 背包优化
    将二维数组转换为一维数组->状态可以压缩   麻将牌 
    上一行的状态计算完以后，可以迭代到下一行 拷贝上一行 再来计算
    - dp[j]  容量为j的背包最大价值
         dp[j] = max(dp[j], dp[j-weight[i]]+value[i])
    - 初始化
         dp[0] = 0
    - 迭代
        for(i = 0;i<weight.length;i++){
            for(j = bagweight;j>=0;j--){
              
            }
        }






