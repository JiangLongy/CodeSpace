# 超文本传输协议HTTP/0.9
1. 客户端发送GET请求，请求一个XXXXX/index.html文件
2. 服务器接收到请求后，读取对应的HTML文件，以ASCII码的字符流返回给客户端

- 特点
1. 只有请求行，没有请求头和请求体
2. 没有响应头
3. 传输的内容是以ASCII的字符流形式传输的

# HTTP /1.0
相比于0.9，1.0版本可以支持多种类型文件的传输

通过引入请求头和响应头，来让客户端和服务端能更加深入地交流 key-value形式

- 为什么有了请求头和响应头就能支持多种文件的数据传输

请求头: accept: text/html
        accept-encoding: gzip

响应头: content-encoding: br
        content-type: text/html ;charset=utf-8

# HTTP /1.1
持久连接，一个TCP连接建立，可以传输多个http请求，减少了大量TCP连接和断开连接带来的开销
Connection: keep-alive ||close 持久连接是否开启

浏览器默认支持六个TCP持久连接

- 队头堵塞  TCP只支持一个请求
  1. 管线化:批量发送请求（pass）

- 虚拟机
  请求头: Host 字段 

- 动态内容
   1.0 content-Length：1024 后端告诉前端我传的数据有多大

   Chunk transfer 机制: 将数据分割成若干个任意大小的数据块，每个数据块标记好长度，最后发送一个长度为0的数据块来标志发送完毕

# HTTP /2.0

- 1.1 的问题: 带宽用不满 
      1. TCP的慢启动: 拥塞控制算法导致一定会慢启动，慢启动导致页面关键资源加载时间推后
      2. 多条TCP连接竞争带宽导致每条TCP连接中能被分配的带宽大大降低
      3. 队头阻塞问题 前一个请求延迟，后一个请求便无法发送，导致带宽浪费

- 2.0 多路复用
1. 一个域名只使用一个TCP长连接
2. 将每一个请求分成一帧一帧的数据进行传输并打上编号，同时发送给服务端，且可以在重要资源请求中标记为加急，服务端接收到带有各种编号的数据帧后，可以区分哪个数据帧加急，优先整理和响应该请求的数据帧（通过引入了二进制分帧成实现多路复用）

# http和https
GET /images/logo.png  HTTP/1.1 请求行
幂等：注册十次和二十次不是幂等，更改文章10次和20次是幂等

- GET VS POST (副作用->影响服务器上的资源和幂等)
1. GET用于无副作用幂等的场景，而POST用于有副作用不幂等的场景
2. GET请求能缓存，POST不能 
3. POST相对安全一点，POST的参数在请求体中，GET的参数是拼接在URL中
4. URL的长度是有限的，所以GET请求会受影响，而POST不会
5. POST支持更多的编码类型，且不对数据类型做限制

# HTTP状态码
  - 2XX  
    200
    204
    205
    206

  - 3XX
    301
    302
    303
    304

  - 4XX
    400
    401
    403
    404    
     
  - 5XX
    500
    501
    503 

![alt text](image.png)

- TLS协议

HTTPS = HTTP + TLS

1. 对称加密
双方都要有相同的密钥，双方都知道如何加密和解密

问题: 如何让双方都具有相同的密钥，通过网络传输该密钥，一旦被截获，那么之后的内容加密也无意义
2. 非对称加密
服务端生成公钥和私钥，将公钥发布出来，客户端接收到公钥后生成一个密钥，再利用公钥加密该密钥传输给服务端，服务端用独有的私钥解密得到密钥
![alt text](ef9292aa97de130de4319dbee73928c8.png)

# HTTP /3.0
2.0的缺陷:
  1. TCP的队头阻塞：当单个数据包丢失时，TCP会暂停后续包的传输，先重传丢失的包数据
  2. TCP慢启动

- TCP协议僵化: TCP常用于物理层，一旦TCP修改(路由器，交换机，防火墙)全部失效，全部要更新

- QUIC协议: 基于UDP协议，在UDP上实现了类似于TCP的多路数据流、可靠性传输等功能
   1. 实现了类似于TCP的流量控制和可靠性传输
   2. 集成了TLS加密功能
   3. 实现了HTTP2中的多路复用

- 挑战


